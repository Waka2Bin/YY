#include <iostream>
#include <vector>
#include <fstream>
#include <sstream>
#include <cmath>
#include <algorithm>
#include <numeric>

struct polk
{
    long long id = -1;
    long long chs = 0;
    long long pr_sum;
};





int main()
{
    using namespace std;
    // ifstream in("input.txt");
    //ofstream out("output.txt");


  ifstream cin("C:\\Users\\ermolaevDA\\Documents\\build-untitled_zapret-Desktop_Qt_5_15_1_MinGW_32_bit-Debug\\debug\\7.txt");
//   //ofstream cout("C:/Users/ermolaevDA/Documents/build-untitled_zapret-Desktop_Qt_5_15_1_MinGW_32_bit-Debug/debug/output.txt");

   size_t n, m;
   cin >> n >> m;
   vector < polk > p(n + 1);//ЧИСЛО ОРКОВ О ПОЛКАМ

   long long sum = 0;
   for (size_t i = 0 ; i < n ; i++)
   {
       polk t;
       cin >> t.chs;
       t.pr_sum = sum;
       sum += t.chs;
       t.id = i + 1;
       p[ i ] = t;
   }
   //Барьер прификса
   polk t;
   t.pr_sum = sum;
   p[ n ] = t;

   vector < pair <long long , long long> > r(m); // КОЛИЧЕСТВО ПОЛКОВ И СУММАРНОЕ КОЛИЧЕСТВО ОРКОВ В ЭТИХ ПОЛКАХ
   vector < long long > rez(m);//НОМЕР ПОЛКА ОТПРАВЯЛЮЯЩЕГОСЯ ПЕРВЫМ( ЕCЛИ ЕСТЬ)
   for (size_t i = 0 ; i < m ; i++)
   {
       cin >> r[ i ].first >> r[ i ].second;
       rez[ i ] = -1;
   }

   for (size_t i = 0; i < r.size(); i++)
   {
       long long s = 0;
       long long e = p.size() - 1;
       while ( e - s > r[i].first )
       {
           long long mid = ( s + e ) / 2 ;
           long long mid_e = mid - r[i].first;
           long long mid_e1 = mid + r[i].first;
           if (mid_e < s)
               mid_e = s;
           long long u = 0;
               u = p[ mid_e + r[i].first ].pr_sum - p[ mid_e ].pr_sum;
           if ( u == r[i].second)
           {
               rez[i] = p[ mid_e ].id;
               break;
           }
           if (mid_e1 > e)
               mid_e1 = e;
           long long u1 = 0;
               u1 = p[ mid_e1 ].pr_sum - p[ mid_e1 - r[i].first ].pr_sum;
           if ( u1 == r[i].second)
           {
               rez[i] = p[ mid_e1 - r[i].first ].id;
               break;
           }
           
           //определение нового интервала
            if (  (u < r[i].second && u1 < r[i].second) )
                s = mid_e + 1  ;
            else if (  (u > r[i].second && u1 > r[i].second) )
                e = mid_e1 - 1 ;
            else if (  u < r[i].second && u1 > r[i].second)
            {
                s = mid_e + 1;
                e = mid_e1 - 1 ;
            }
       }
//out<< "ghh _________ "<< rez[0]<< " "  << i << endl;
   }

   for ( const auto &t:rez)
       cout << t << endl;

   return 0;
}